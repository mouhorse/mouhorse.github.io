<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lucky | Lucky</title><meta name="author" content="刘同学"><meta name="copyright" content="刘同学"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JUC - wolai 笔记基础知识Java多线程和操作系统多线程是一样的，内部也是一对一的关系并发与并行区别并发：多核CPU下同一CPU运行多个进程的能力。并行：多个进程同时被运行，单核CPU没法实现。保证数据一致性的方案事务管理：一组数据库操作要么全部成功提交，要么全部失败回滚。锁机制：锁来实现对共享资源的互斥访问版本控制：乐观锁的方式创建线程的方法继承Thread类run方法定义了线程需要">
<meta property="og:type" content="website">
<meta property="og:title" content="Lucky">
<meta property="og:url" content="https://mouhorse.github.io/myJava/java/juc/juc.html">
<meta property="og:site_name" content="Lucky">
<meta property="og:description" content="JUC - wolai 笔记基础知识Java多线程和操作系统多线程是一样的，内部也是一对一的关系并发与并行区别并发：多核CPU下同一CPU运行多个进程的能力。并行：多个进程同时被运行，单核CPU没法实现。保证数据一致性的方案事务管理：一组数据库操作要么全部成功提交，要么全部失败回滚。锁机制：锁来实现对共享资源的互斥访问版本控制：乐观锁的方式创建线程的方法继承Thread类run方法定义了线程需要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mouhorse.github.io/img/tou.png">
<meta property="article:published_time" content="2025-03-26T05:02:16.353Z">
<meta property="article:modified_time" content="2025-03-26T05:01:54.398Z">
<meta property="article:author" content="刘同学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mouhorse.github.io/img/tou.png"><link rel="shortcut icon" href="/img/th.png"><link rel="canonical" href="https://mouhorse.github.io/myJava/java/juc/juc.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="google-site-verification" content="Bc4tRfMaw7XnqS-KACjzLzmUvYz5yXYVWsfdC3iux4k"/><meta name="baidu-site-verification" content="codeva-E9MpML203E"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lucky',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'page'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/tou.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-music"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url(/img/background.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/th.png" alt="Logo"><span class="site-name">Lucky</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/shuoshuo/"><i class="fa-fw fas fa-music"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="page-site-info"><h1 id="site-title"></h1></div></header><main class="layout" id="content-inner"><div id="page"><div class="container" id="article-container"><!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../../css/wolai.css"/><title>JUC - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="JUC" class="main-title"></div></div></header><article><h1 id="kBLsnr6tB3uhiZHYhbScwo" class="wolai-block"><span class="inline-wrap">基础知识</span></h1><div id="9X4Dco8j86AR2iDVhPFXbX" class="wolai-block wolai-text"><div><span class="inline-wrap">Java<span class="jill"></span>多线程和操作系统多线程是一样的，内部也是一对一的关系</span></div></div><h2 id="bzSFNxbeUqrfpfxYUew7rp" class="wolai-block"><span class="inline-wrap">并发与并行区别</span></h2><div id="n5fMiANhoQTDYyogGnFSt2" class="wolai-block wolai-text"><div><span class="inline-wrap">并发：多核<span class="jill"></span>CPU<span class="jill"></span>下同一<span class="jill"></span>CPU<span class="jill"></span>运行多个进程的能力。</span></div></div><div id="hKnM4iHjT7r322iPqRPxzy" class="wolai-block wolai-text"><div><span class="inline-wrap">并行：多个进程同时被运行，单核<span class="jill"></span>CPU<span class="jill"></span>没法实现。</span></div></div><h2 id="dAjVXGKAsve6UKEAcdgJRs" class="wolai-block"><span class="inline-wrap">保证数据一致性的方案</span></h2><ul class="wolai-block"><li id="74Vc2Rv7Y76cDagoXnTgg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">事务管理：一组数据库操作要么全部成功提交，要么全部失败回滚。</span></li><li id="fFrfGvnPFXUphBmGedc8JV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">锁机制：锁来实现对共享资源的互斥访问</span></li><li id="hX85JhgX5xkNzGXaeBjCge"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">版本控制：乐观锁的方式</span></li></ul><h2 id="3XFyfaY66o1TMjo1dpUpyM" class="wolai-block"><span class="inline-wrap">创建线程的方法</span></h2><h3 id="mVpZYX6DFHxMdpb1CSNbfF" class="wolai-block"><span class="inline-wrap">继承<span class="jill"></span>Thread<span class="jill"></span>类</span></h3><div id="u36jkVwqDxUnhidPtbubJB" class="wolai-block wolai-text"><div><span class="inline-wrap">run<span class="jill"></span>方法定义了线程需要运行的核心代码</span></div></div><div id="ek9bNbXje4UViUDJ3gvE79" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>start<span class="jill"></span>方法启动线程</span></div></div><code-block id="wJSUBe1gtVDBtGhehdM6Y" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 线程执行的代码</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">MyThread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></pre></div></code-block><h3 id="atE3yS4ZouveioDVRkCCoF" class="wolai-block"><span class="inline-wrap">Runable<span class="jill"></span>接口</span></h3><div id="wjEGzFGVKiN7eBJyfcMHur" class="wolai-block wolai-text"><div><span class="inline-wrap">因为类只能继承一个，所示使用接口实现多线程，灵活性更高</span></div></div><code-block id="nP8XU5RhwciNNXQhGcNBpe" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 线程执行的代码</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</pre></div></code-block><h3 id="utfDxSDM7SSZyavERrJPhh" class="wolai-block"><span class="inline-wrap">Callable<span class="jill"></span>接口</span></h3><div id="kEWMUbqF1B7rrg5f1ey63Y" class="wolai-block wolai-text"><div><span class="inline-wrap">类似于<span class="jill"></span>Runnable，但<span class="jill"></span>Callable<span class="jill"></span>的<span class="jill"></span>call()方法可以</span><span class="red inline-wrap"><b>有返回值</b></span><span class="inline-wrap">并且可以抛出异常</span></div></div><div id="udp76kb8tTuMa237VRk8Pf" class="wolai-block wolai-text"><div><span class="inline-wrap">call<span class="jill"></span>为多线程核心代码，返回值和继承接口填入的返回值需要保持相同</span></div></div><code-block id="4dJB4S2JPqiNjxR4YAnuG4" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 线程执行的代码，这里返回一个整型结果</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 需要先把Callable封装成FutureTask，再封装为Thread</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">MyCallable</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Integer</span> result <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取线程执行结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result: "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">ExecutionException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></pre></div></code-block><h3 id="bThsKLQ4dtFEd9kKhDgGJu" class="wolai-block"><span class="inline-wrap">线程池</span></h3><div id="4fGpH9ztyQUD65eceWsLAp" class="wolai-block wolai-text"><div><span class="inline-wrap">类首先还是需要实现<span class="jill"></span>Runable<span class="jill"></span>接口或者<span class="jill"></span>Callable<span class="jill"></span>接口，然后提交给线程池。</span></div></div><div id="eX4xYSxwsVX2VQn8XEMVDA" class="wolai-block wolai-text"><div><span class="inline-wrap">是一种更高效的线程管理方式，避免了频繁创建和销毁线程的开销</span></div></div><code-block id="pxF6Zgobqjz7fzFa5wR2Kf" class="wolai-block"><div class="wolai-pre"><div data-lang="Java" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 线程执行的代码</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">ExecutorService</span> executor <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 创建固定大小的线程池</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        executor<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 提交任务到线程池执行</span>
    <span class="token punctuation">&#125;</span>
    executor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 关闭线程池</span>
<span class="token punctuation">&#125;</span></pre></div></code-block><h2 id="mfPjJqCRwki5vQQ3K6GiN8" class="wolai-block"><span class="inline-wrap">线程的状态</span></h2><div id="aVTMvQK36MUj3m18XqfFyM" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 169px"><span class="inline-wrap"></span><div id="raR15gqYkN6RiP4TSh2x8p" class="wolai-block wolai-text"><div><span class="inline-wrap">线程状态</span></div></div></th><th style="width: 563px"><span class="inline-wrap"></span><div id="9Kq9r1jN4wJmc7CThW1a3W" class="wolai-block wolai-text"><div><span class="inline-wrap">解释</span></div></div></th></tr></thead><tbody><tr><td><span class="inline-wrap"></span><div id="v7hZzgPTAd5w87u1jLGinB" class="wolai-block wolai-text"><div><span class="inline-wrap">NEW</span></div></div></td><td><span class="inline-wrap"></span><div id="pV3u2CoxNkfd9iZvqafNA3" class="wolai-block wolai-text"><div><span class="inline-wrap">尚未启动的线程状态，即线程创建，</span><span class="inline-wrap"><b>还未调用<span class="jill"></span>start<span class="jill"></span>方法</b></span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="e5Fe5CFMi72Pe4Xt6AshUQ" class="wolai-block wolai-text"><div><span class="inline-wrap">RUNNABLE</span></div></div></td><td><span class="inline-wrap"></span><div id="4pgWrWWqixNzcwbVVu2CoM" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>就绪状态</b></span><span class="inline-wrap">（调用<span class="jill"></span>start，等待调度）+</span><span class="inline-wrap"><b>正在运行</b></span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="bYLQLoqjh1am5RBb1V7CaE" class="wolai-block wolai-text"><div><span class="inline-wrap">BLOCKED</span></div></div></td><td><span class="inline-wrap"></span><div id="qxFq9BQnsch3UtLPLE4VPp" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>等待监视器锁</b></span><span class="inline-wrap">时，陷入阻塞状态</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="uRL42Kz79dEe3fFtir1PHk" class="wolai-block wolai-text"><div><span class="inline-wrap">WAITING</span></div></div></td><td><span class="inline-wrap"></span><div id="gjEjD5NWnAVkDdMjyAkSfK" class="wolai-block wolai-text"><div><span class="inline-wrap">等待状态的线程正在</span><span class="inline-wrap"><b>等待</b></span><span class="inline-wrap">另一线程执行特定的操作（如<span class="jill"></span>notify）</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="kd2eBPYAziLPL7wXkTx8FV" class="wolai-block wolai-text"><div><span class="inline-wrap">TIMED_WAITING</span></div></div></td><td><span class="inline-wrap"></span><div id="5L2PCYmDjZ9NH8RBaoXdYs" class="wolai-block wolai-text"><div><span class="inline-wrap">具有</span><span class="inline-wrap"><b>指定等待时间</b></span><span class="inline-wrap">的等待状态</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="bMqZKD2XpBg9xcoq9kq3Gb" class="wolai-block wolai-text"><div><span class="inline-wrap">TERMINATED</span></div></div></td><td><span class="inline-wrap"></span><div id="dvtPob1dt4ux5TVkBM9CK1" class="wolai-block wolai-text"><div><span class="inline-wrap">线程完成执行，</span><span class="inline-wrap"><b>终止状态</b></span></div></div></td></tr></tbody></table></div><h2 id="nVwRNP8A9D6sX6bem97Khi" class="wolai-block"><span class="inline-wrap">不用<span class="jill"></span>start<span class="jill"></span>直接<span class="jill"></span>run()</span></h2><div id="vnVakSw5Lthxmizd728iC7" class="wolai-block wolai-text"><div><span class="inline-wrap">这样的话就不是多线程了只有<span class="jill"></span>start<span class="jill"></span>会创建一个新线程。然后调用<span class="jill"></span>run<span class="jill"></span>执行新线程的启动。</span></div></div><h3 id="9t3NM1PpbVEZbu1wDefeqp" class="wolai-block"><span class="inline-wrap">blocked<span class="jill"></span>和<span class="jill"></span>waiting<span class="jill"></span>区别</span></h3><div id="2WDUsmCtG5Bqr18427MzvG" class="wolai-block wolai-text"><div><span class="inline-wrap">blocked<span class="jill"></span>是请求临界资源，但是被其他线程正在使用</span></div></div><div id="3WL9M7PcySyt3Smy8oSVEk" class="wolai-block wolai-text"><div><span class="inline-wrap">waiting<span class="jill"></span>是等待另一个线程的返回值</span></div></div><h3 id="sLKRV92ccU9JMsR2cwikeA" class="wolai-block"><span class="inline-wrap">唤醒<span class="jill"></span>wait</span></h3><div id="qYZ7ymVnVWpygAyJHsuhYN" class="wolai-block wolai-text"><div><span class="inline-wrap">自己睡醒：</span><span class="inline-wrap"><code>LockSupport.unpark(Thread)</code></span><span class="inline-wrap">  ，前提是被 </span><span class="inline-wrap"><code>LockSupport.park()</code></span><span class="inline-wrap">催眠的</span></div></div><div id="66ZLt3DEwbLsPB5dqBZrw5" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><div id="agTA7C8MK3YSuD3bR9FnfC" class="wolai-block wolai-text"><div><span class="inline-wrap">被其他线程唤醒：</span><span class="inline-wrap"><code>notify()</code></span><span class="inline-wrap"> , </span><span class="inline-wrap"><code>notifyAll()</code></span></div></div><div id="by3d2J77f8rK3NjwHpHZdJ" class="wolai-block wolai-text"><div><span class="inline-wrap">两个语句同样是唤醒等待的线程，同样最多只有一个线程能获得锁，同样不能控制哪个线程获得锁。</span></div></div><div id="nLUanR6WTd96nBsyg8MLQ2" class="wolai-block wolai-text"><div><span class="inline-wrap">区别在于：</span></div></div><ul class="wolai-block"><li id="4QWxobaiqsw8DGcPcMZKBg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">notify：</span><span class="inline-wrap"><b>唤醒一个线程</b></span><span class="inline-wrap">，其他线程依然处于<span class="jill"></span>wait<span class="jill"></span>的等待唤醒状态，如果被唤醒的线程结束时没调用<span class="jill"></span>notify，其他线程就永远没人去唤醒，只能等待超时，或者被中断</span></li><li id="tA3hviVvBwvHPyvQyAF9vA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">notifyAll：</span><span class="inline-wrap"><b>所有线程</b></span><span class="inline-wrap">退出<span class="jill"></span>wait<span class="jill"></span>的状态，开始竞争锁，但只有一个线程能抢到，这个线程执行完后，其他线程又会有一个幸运儿脱颖而出得到锁。</span></li></ul><div id="x8Kz9PM43YYoQZHG6G4YHw" class="wolai-block wolai-text"><div><span class="inline-wrap">noyify<span class="jill"></span>具体唤醒哪个，和<span class="jill"></span>JVM<span class="jill"></span>有关，比如随机唤醒或者先进先出</span></div></div><h2 id="b6fNzZLidQ7sgqatq9D7KN" class="wolai-block"><span class="inline-wrap">停止线程的运行</span></h2><ul class="wolai-block"><li id="gdCuDWFdWj6WgH3esqdUWb"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>return</b></span><span class="inline-wrap">：调用<span class="jill"></span>interrupt<span class="jill"></span>标记为中断状态后，在<span class="jill"></span>run<span class="jill"></span>方法中判断当前线程状态，如果为中断状态则<span class="jill"></span>return，能达到停止线程的效果。</span></li><li id="frdbJ3e5ZRC2rigAT9Z5XP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>异常</b></span><span class="inline-wrap">：线程调用<span class="jill"></span>interrupt()方法后，在线程的<span class="jill"></span>run<span class="jill"></span>方法中判断当前对象的<span class="jill"></span>interrupted()状态，如果是中断状态则抛出异常，达到中断线程的效果。</span></li><li id="hCFxUVneaKu52m1hkwTvPj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>sleep</b></span><span class="inline-wrap">：先将线程<span class="jill"></span>sleep，然后调用<span class="jill"></span>interrupt<span class="jill"></span>标记中断状态，interrupt<span class="jill"></span>会将阻塞状态的线程中断。会抛出中断异常，达到停止线程的效果。</span></li><li id="42uGDDccHN7sXCkFSo7BaF"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">stop()暴力停止</span><span class="inline-wrap">：线程调用<span class="jill"></span>stop()方法会被暴力停止，方法已弃用，该方法会有不好的后果：强制让线程停止有可能使一些请理性的工作得不到完成。</span></li></ul><h2 id="mBuAuLcQd72feH1bqRUG85" class="wolai-block"><span class="inline-wrap">线程调度方法</span></h2><div id="4KELBBMDCSfgLJZb6bRBrs" class="wolai-block"><figure class="wolai-center" style="width: 339px; flex-direction: column"><img src="media/image.png" style="width: 100%"/></figure></div><ul class="wolai-block"><li id="v2ZfVYdsnKquyHyjGsyder"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">wait：调用或线程会被挂起，直到有线程调用<span class="jill"></span>notify，或者到达时间。</span><ul class="wolai-block"><li id="4MywmCJuNYrHgTXXa9S6wj"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">notify</span></li><li id="oMLPH8ZCHKCB3zAnpo47fz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">notifyall</span></li></ul></li><li id="mRodWQPk4qMn1s6cahh685"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">yield：从运行态变为就绪态</span></li><li id="ruqTUnU6GesvBtjPk5iABy"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">sleep：暂时让出<span class="jill"></span>cpu，醒后继续执行</span></li></ul><h3 id="3ZeeTHDaJPL3qwTPzMFQJU" class="wolai-block"><span class="inline-wrap">sleep vs wait</span></h3><ul class="wolai-block"><li id="o2RFMtx2kAYBRG86B7k3dm"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">sleep<span class="jill"></span>属于<span class="jill"></span>Thread<span class="jill"></span>类的方法。wait<span class="jill"></span>属于<span class="jill"></span>Object<span class="jill"></span>类的方法</span></li><li id="upjRqjbmL9wCNKVaMCa6mZ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">sleep<span class="jill"></span>是不会释放其他锁，wait<span class="jill"></span>会释放获得的锁</span></li><li id="gdxjRsCiiiGYwPVuRputED"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">sleep<span class="jill"></span>可以在任何地方调用，wait<span class="jill"></span>只能在同步方法中调用</span></li></ul><h1 id="trStoYES4r891D8hdDP3Bd" class="wolai-block"><span class="inline-wrap">并发安全</span></h1><h2 id="iaNDhJQb8xNUjeM35NSweK" class="wolai-block"><span class="inline-wrap">Synchronized</span></h2><div id="55QK1NsK1YN2T4hLRwPzsf" class="wolai-block wolai-text"><div><span class="inline-wrap">内置锁，同一时刻只有一个线程能够持有对象锁。</span></div></div><div id="62m8nVi3r4wuuAcHZXJ15S" class="wolai-block wolai-text"><div><span class="inline-wrap">也是可重入锁，自己拥有锁后，其子线程可以成功请求锁，而不必阻塞。</span></div></div><div id="tWFUzX5rVFQvnEcGXT4LbH" class="wolai-block wolai-text"><div><span class="inline-wrap">是对象锁，</span><span class="inline-wrap"><u>每个对象有自己的对象</u></span><span class="inline-wrap">锁 ，集群要用到分布式锁。</span></div></div><div id="oAusMBwQEzsMajoatHNqhD" class="wolai-sub-page wolai-block"><div class="page-icon"></div><a href="%E5%AF%B9%E8%B1%A1%E9%94%81%E4%B8%BE%E4%BE%8B/%E5%AF%B9%E8%B1%A1%E9%94%81%E4%B8%BE%E4%BE%8B.html"><span>对象锁举例</span></a></div><div id="f6pg1MWY9ohk9eSXSRMn3m" class="wolai-block wolai-text"><div><span class="inline-wrap">并且<span class="jill"></span>symchronized<span class="jill"></span>也有<span class="jill"></span>violate<span class="jill"></span>的功能，确保变量被其他进程可见。</span></div></div><div id="jzLBQs3cPmwVu9X9m2qmJJ" class="wolai-block wolai-text"><div><span class="inline-wrap">可以锁：方法，静态方法，对象</span></div></div><div id="rrxBtSPR3BM2uckXFQo3jA" class="wolai-block wolai-text"><div><span class="inline-wrap">同一时刻只有一个线程能够持有对象锁。</span></div></div><div id="ikNMkbeRgr8aNCEpnsoURU" class="wolai-block wolai-text"><div><span class="inline-wrap">也能保证数据在内存中的可见性。</span></div></div><div id="kxTcpx6qsDzL8H5hYVHPHe" class="wolai-block wolai-text"><div><span class="inline-wrap">不过没有指令重排功能，所以不能取代<span class="jill"></span>violate</span></div></div><h3 id="3szERLNqMMDkLUjuonGNbR" class="wolai-block"><span class="inline-wrap">底层实现</span></h3><div id="oLtRY5hvBK8z13kxRxVTUV" class="wolai-block wolai-text"><div><span class="inline-wrap">Monitor</span></div></div><div id="4BTisDk6Skmi92wzBhfLsx" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_1.png" style="width: 100%"/></figure></div><div id="eoE2sHxnGDiMidaZ9a5zXs" class="wolai-block wolai-text"><div><span class="inline-wrap">当一个对象使用<span class="jill"></span>synchronized<span class="jill"></span>后会先检查<span class="jill"></span>Monitor<span class="jill"></span>的<span class="jill"></span>owner，如果为空，则这个对象赋值给<span class="jill"></span>Owner，然后开始运行。若不为空，则进入<span class="jill"></span>EntryList<span class="jill"></span>等待，等运行的进程结束后，抢占<span class="jill"></span>Owner。调用了<span class="jill"></span>wait<span class="jill"></span>方法的线程在<span class="jill"></span>WaitSet<span class="jill"></span>里面。</span></div></div><h3 id="oMNDxT8qY2SPaWgg6MxfU7" class="wolai-block"><span class="inline-wrap">锁升级</span></h3><div id="vFiJsXFSLRo5rWyc87LRon" class="wolai-block wolai-text"><div><span class="inline-wrap">锁有无锁、偏向锁、轻量级锁和重量级锁几个级别。级别越高，开销越大。</span></div></div><div id="sn52XyQRdYRzMib8kXRQyf" class="wolai-block wolai-text"><div><span class="inline-wrap">锁升级的意义就是适应不同环境下线程的执行。</span></div></div><ul class="wolai-block"><li id="ajy3eY5meRowsQiao55WQ6"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">无锁：一个资源没有被使用的时候</span></li><li id="aLbbNAkMrhsRtxgAgsPxQC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">偏向锁：一个线程访问这个资源，无锁升级为偏向锁。</span></li><li id="ixGehzPX7TVzGshk6uGb1H"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">轻量级锁：两个线程访问这个资源，一个再执行，另一个<span class="jill"></span>CAS<span class="jill"></span>等待</span></li><li id="5sDjKJNJXFn2vNuyyXwrm5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">重量级锁：CSA<span class="jill"></span>超时的话进入重量级锁，有等待队列。</span></li></ul><div id="rsp5GV6ooLFcoxpBxuBdWA" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_2.png" style="width: 100%"/></figure></div><h2 id="dqVAuiG5kDWKiURUJxmgWm" class="wolai-block"><span class="inline-wrap"><b>ReentrantLock</b></span></h2><div id="dS7V8FCXiq3ntmuX2rFBqp" class="wolai-block wolai-text"><div><span class="inline-wrap">提供了比内置锁更高级的功能：可中断的锁等待、定时锁等待、公平锁选项等</span></div></div><ul class="wolai-block"><li id="3dKMGD6LQw7ndiGCc52WSg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">公平锁：先来先服务</span></li><li id="tuRpccNYJAJyzNRJ4S3dcV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">非公平锁：随机抢占</span></li></ul><h2 id="pu4E7CjnMQ5UgmWo1HVnSh" class="wolai-block"><span class="inline-wrap"><b>ReadWriteLock</b></span></h2><div id="rihzkSRtW3qUgbnnfrr5dy" class="wolai-block wolai-text"><div><span class="inline-wrap">读写锁</span></div></div><div id="4M3Lm7G6PgTpdni6KnAhsg" class="wolai-block wolai-text"><div><span class="inline-wrap">只允许一个进程写，但是可以有多个进程同时读。</span></div></div><h2 id="dkQRijsLMchzYLVWV35K7A" class="wolai-block"><span class="inline-wrap">乐观锁和悲观锁</span></h2><div id="eEZrdWy1nkGuvuzCAwWgFB" class="wolai-block wolai-text"><div><span class="inline-wrap">悲观锁（Pessimistic Locking）通常指在访问数据前就锁定资源，假设最坏的情况，即数据很可能被其他线程修改。</span><span class="inline-wrap"><code>synchronized</code></span><span class="inline-wrap">和</span><span class="inline-wrap"><code>ReentrantLock</code></span><span class="inline-wrap">都是悲观锁的例子。</span></div></div><div id="aNJvDtC6mH821G5w163SWY" class="wolai-block wolai-text"><div><span class="inline-wrap">乐观锁（Optimistic Locking）通常不锁定资源，而是在更新数据时检查数据是否已被其他线程修改。乐观锁常使用版本号或时间戳来实现。如果已被修改，那么就重新读取数据，再次修改。</span></div></div><h2 id="jCemLHRLa7f6grR7jEmBUt" class="wolai-block"><span class="inline-wrap">Synchronized<span class="jill"></span>和<span class="jill"></span>ReentrantLock<span class="jill"></span>的区别</span></h2><ul class="wolai-block"><li id="cpwLe5Qrt7ZnRUgfX48HYg"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Synchronized<span class="jill"></span>是<span class="jill"></span>JVM<span class="jill"></span>内置的自动上锁解锁，ReentrantLock<span class="jill"></span>基于<span class="jill"></span>AQS<span class="jill"></span>需要手动<span class="jill"></span>lock，unlock</span></li><li id="7njKZyNcs8i1Z1td2KCwjL"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ReentrantLock<span class="jill"></span>功能丰富，允许等待锁的过程中响应中断</span></li><li id="v3bey5aXQL4R1WvZnFr7Y5"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">ReentrantLock<span class="jill"></span>可能会导致死锁，因为要手动上锁解锁</span></li><li id="9SYai2WeKx9fC1jTGen9mR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Synchronized<span class="jill"></span>适用于低竞争场景</span></li><li id="pAGZYod4fpDDo82gkrwRPp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">Synchronized<span class="jill"></span>是非公平锁，ReentrantLock<span class="jill"></span>是公平锁。</span></li></ul><h2 id="bJvcEefedEDni6Ft5PvY2b" class="wolai-block"><span class="red inline-wrap"><b>Threadlocal</b></span></h2><div id="3CW5ULK2821gEzYiU7EBMP" class="wolai-block wolai-text"><div><span class="inline-wrap">就是对用来存储每个线程自己的局部变量，每个线程有属于自己的<span class="jill"></span>Threadlocal。</span></div></div><div id="5cMmcszv8L8YVwNZQHvJpZ" class="wolai-block wolai-text"><div><span class="inline-wrap">即使是父线程的<span class="jill"></span>ThreadLocal<span class="jill"></span>也不能被子线程访问。</span></div></div><div id="qE8R5C3RtpimaLhT9zKCpy" class="wolai-block wolai-text"><div><span class="inline-wrap">变量存储在<span class="jill"></span>ThreadLocalMap<span class="jill"></span>内，key</span><span class="inline-wrap"><b>是</b></span><span class="inline-wrap">ThreadLocal<span class="jill"></span>对象，value<span class="jill"></span>是<span class="jill"></span>ThreadLocal<span class="jill"></span>对象值</span></div></div><h3 id="qEht4hTVWVeE25oJvdBamX" class="wolai-block"><span class="inline-wrap">引用类型</span></h3><ul class="wolai-block"><li id="v7piF52536dhVa4rJU3iDH"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap">强引用</span><span class="inline-wrap">: 最普通的引用 Object o = new Object()</span></li><li id="g8xYxjW2pKV1biaiNoFavu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap">软引用</span><span class="inline-wrap">: 垃圾回收器, 内存不够的时候回收 (缓存)</span></li><li id="gDeqCjKWzC9UFckXMEwBEz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap">弱引用</span><span class="inline-wrap">: 垃圾回收器看见就会回收 (防止内存泄漏)</span></li><li id="7CcLng7UNjbpwiPrRkLQbS"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="blue inline-wrap">虚引用</span><span class="inline-wrap">: 垃圾回收器看见二话不说就回收,跟没有一样 (管理堆外内存)。</span></li></ul><h3 id="e7De4Y5ux9SV7a37m77tdi" class="wolai-block"><span class="inline-wrap">作用</span></h3><ul class="wolai-block"><li id="bdqjjj4J4XmYKdqvW1f8k"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>线程隔离</b></span><span class="inline-wrap">：不同线程之间不必担心数据同步或竞争问题。</span></li><li id="icvmmTeHTfvXXuTGpK85hc"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">降低耦合度：同一线程的不同方法之间可以使用<span class="jill"></span>Threadlocal<span class="jill"></span>传递参数。</span></li><li id="mzBub85pXhyqv46bLCqoG"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">性能优势：比锁能提供更好的性能。</span></li></ul><h3 id="i1UdsxDe37uDEm5TiyoGrq" class="wolai-block"><span class="inline-wrap">内存泄漏</span></h3><div id="st3YgtHgRufrEkthHoGPGs" class="wolai-block wolai-text"><div><span class="inline-wrap">Map<span class="jill"></span>里面的<span class="jill"></span>key<span class="jill"></span>是弱引用，value<span class="jill"></span>是强引用</span></div></div><div id="6H9GD4DAFb9iRnSkVSSh8E" class="wolai-block wolai-text"><div><span class="inline-wrap">强引用不会被<span class="jill"></span>JVM<span class="jill"></span>垃圾回收，所以要主动释放。</span></div></div><div id="mcvAgHbPuZCfgXqbSHqZJ6" class="wolai-block wolai-text"><div><span class="inline-wrap">因此如果不主动调用</span><span class="inline-wrap"><u>remove</u></span><span class="inline-wrap">方法，可能会导致内存泄漏(就是内存不足)</span></div></div><h3 id="tg5AFV7zwgR2KkNK1giUWT" class="wolai-block"><span class="inline-wrap">用到的地方</span></h3><div id="uskepbi86wvugzdsGu7Gv4" class="wolai-block wolai-text"><div><span class="inline-wrap">用户登录后的用户信息存到了<span class="jill"></span>ThreadLocal<span class="jill"></span>里面，方便应用层、服务层、控制层的使用。</span></div></div><h2 id="d6tk3Nc17pNgJ5XuKf47Vg" class="wolai-block"><span class="inline-wrap">JMM(Java<span class="jill"></span>内存模型)</span></h2><div id="pcuQynnCELGSV3QwQJ85vZ" class="wolai-block wolai-text"><div><span class="inline-wrap">Java Memory Model ，上面是线程独享的变量，这里是共享的变量。</span></div></div><div id="vyhzs14GwV6otHUoZeVQTU" class="wolai-block wolai-text"><div><span class="inline-wrap">不同进程的工作空间是独立的，不能互相访问，所以不存在线程安全问题。</span></div></div><div id="7yukRfnnwkj1TxKM3eK5zQ" class="wolai-block wolai-text"><div><span class="inline-wrap">两个线程之间的通信用<span class="jill"></span>JMM<span class="jill"></span>控制，线程之间的共享变量存在于主存中。</span></div></div><div id="u6XxDprXSmq6oVM7wrSjic" class="wolai-block wolai-text"><div><span class="inline-wrap">线程自己的空间存的有数据副本。</span></div></div><div id="t7RMuq8HeokSHbDuC4XSEP" class="wolai-block"><figure class="wolai-center" style="width: 422px; flex-direction: column"><img src="media/image_3.png" style="width: 100%"/></figure></div><div id="oSgWY2Cx1bZwFsKsRugezo" class="wolai-block wolai-text"><div><span class="inline-wrap">线程之间通信需要<span class="jill"></span>A<span class="jill"></span>先把自己的变量副本更新到主存内，B<span class="jill"></span>从主存内读取更新过后的共享变量。</span></div></div><div id="3EHFTo3fZVzftTe1eZ5ZJP" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>JMM 通过控制主存与每个线程的本地内存之间的交互</b></span><span class="inline-wrap">。</span></div></div><h3 id="9jdW1b8i5RLXTEuJKy5MEW" class="wolai-block"><span class="inline-wrap">i++<span class="jill"></span>不是原子性</span></h3><div id="xvqjsz9w7scD5HFo5cSbHV" class="wolai-block wolai-text"><div><span class="inline-wrap">分为三步</span></div></div><ul class="wolai-block"><li id="aRf9pLw5kQJDSMKevZLMtC"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">读数据</span></li><li id="mkgE71PCUqMrD5W6tCbBbP"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">修改数据</span></li><li id="idHKzuhGAdsJsYaXxm3K1u"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">写数据</span></li></ul><h3 id="uVqxjNdpwp4r9kDnwckX6U" class="wolai-block"><span class="inline-wrap">指令重排</span></h3><div id="bfF8aS1mL3VqHQj2SkNo9Q" class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>为了提高程序的运行效率，对代码执行的顺序进行了优化。</span></div></div><h3 id="p2BSiDK2pcLoJfu5wijZhF" class="wolai-block"><span class="inline-wrap">Happens-Before</span></h3><div id="dhUXY1qGE4NquLu3hbZpng" class="wolai-block wolai-text"><div><span class="inline-wrap">如果<span class="jill"></span>A Happens-Before B，那么<span class="jill"></span>A<span class="jill"></span>的操作结果对<span class="jill"></span>B<span class="jill"></span>可见，且<span class="jill"></span>A<span class="jill"></span>比<span class="jill"></span>B<span class="jill"></span>先执行。</span></div></div><h2 id="qYyyXCd8FWv4HA569aLe3W" class="wolai-block"><span class="inline-wrap">violate<span class="jill"></span>关键字</span></h2><div id="rZkPyDQBYzywrxYpFP86Hd" class="wolai-block wolai-text"><div><span class="inline-wrap">JMM<span class="jill"></span>会把<span class="jill"></span>violate<span class="jill"></span>修饰的变量放到共享内存中，通过插入不同的屏障确保不会进行指令重排。</span></div></div><h3 id="jKdyKHbnRUy4ZiENHZ26BT" class="wolai-block"><span class="inline-wrap">作用</span></h3><ul class="wolai-block"><li id="cSZ9Uk3GZiyByii25WFZ4w"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">保证变量线程之间的可见性：变量被声明为<span class="jill"></span>volatile<span class="jill"></span>时，它会保证对这个变量的写操作会立即刷新到主存中，而对这个变量的读操作会直接从主存中读取</span></li><li id="2yjYdkBRC7BUzezPdhDA5f"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">禁止</span><span class="inline-wrap">指令重排序优化</span><span class="inline-wrap">：比如代码 x = 1; y = 1;，在<span class="jill"></span>jvm<span class="jill"></span>内部可能是先给<span class="jill"></span>y<span class="jill"></span>赋值，再给<span class="jill"></span>x<span class="jill"></span>赋值</span><ul class="wolai-block"><li id="6oQFHWamuo2MYuELJQHdV4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">1）</span><span class="inline-wrap"><b>写-写（Write-Write）屏障</b></span><span class="inline-wrap">：在对<span class="jill"></span>volatile<span class="jill"></span>变量执行写操作之前，会插入一个写屏障。这确保了在该变量写操作之前的所有普通写操作都已完成，防止了这些写操作被移到<span class="jill"></span>volatile<span class="jill"></span>写操作之后。</span></li><li id="tJQ5DAT3C9WbaZ392dP1Tu"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">2）</span><span class="inline-wrap"><b>读-写（Read-Write）屏障</b></span><span class="inline-wrap">：在对<span class="jill"></span>volatile<span class="jill"></span>变量执行读操作之后，会插入一个读屏障。它确保了对<span class="jill"></span>volatile<span class="jill"></span>变量的读操作之后的所有普通读操作都不会被提前到<span class="jill"></span>volatile<span class="jill"></span>读之前执行，保证了读取到的数据是最新的。</span></li><li id="tygwdauG4sLF6neyNgjTS7"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">3）</span><span class="inline-wrap"><b>写-读（Write-Read）屏障</b></span><span class="inline-wrap">：这是最重要的一个屏障，它发生在<span class="jill"></span>volatile<span class="jill"></span>写之后和<span class="jill"></span>volatile<span class="jill"></span>读之前。这个屏障确保了<span class="jill"></span>volatile<span class="jill"></span>写操作之前的所有内存操作（包括写操作）都不会被重排序到<span class="jill"></span>volatile<span class="jill"></span>读之后，同时也确保了<span class="jill"></span>volatile<span class="jill"></span>读操作之后的所有内存操作（包括读操作）都不会被重排序到<span class="jill"></span>volatile<span class="jill"></span>写之前</span></li></ul></li></ul><div id="3PXSaiv4gnGq6hd6tivXFR" class="wolai-block"><figure class="wolai-center" style="width: 568.2242712107018px; flex-direction: column"><img src="media/image_4.png" style="width: 100%"/></figure></div><h2 id="9Bra4kGjrM8L3Cgc3kWbYg" class="wolai-block"><span class="inline-wrap">CAS</span></h2><div id="uWpX6jG2wKp6vstUb8LK3r" class="wolai-block wolai-text"><div><span class="inline-wrap">Compare And Swap，体现了</span><span class="inline-wrap"><b>乐观锁</b></span><span class="inline-wrap">的思想，在无锁的情况下保证共享数据的原子性。</span></div></div><div id="bg8ULFYKHw1gcGcxKyWduG" class="wolai-block wolai-text"><div><span class="blue inline-wrap">在需要抢锁的时候就判断目标变量的值是否是预期的，是的话就获得锁并更新值，不是的话就循环等待。</span></div></div><div id="nWHTD3K7cK4uM6rZq47cze" class="wolai-block wolai-text"><div><span class="inline-wrap"><code>自旋锁</code></span><span class="inline-wrap"> 运行不成功就一直死循环，直至成功。</span></div></div><div id="hvwHA19tmPiX4RyNS6HcqQ" class="wolai-block wolai-text"><div><span class="inline-wrap">优势：进程不会阻塞，效率高。如果自旋次数过多，效率也会变低，一般设置阈值。 </span></div></div><h3 id="fGRnVp7tSSigKU5Yu2gev1" class="wolai-block"><span class="inline-wrap">ABA<span class="jill"></span>问题</span></h3><code-block id="eDCxgRJTjiZpYES85nWHxz" class="wolai-block"><div class="wolai-pre"><div data-lang="Text" class="marker"></div><pre>线程 1：CAS(A → B)，修改变量 A → B
线程 2：CAS(B → A)，变量又变回 A
线程 3：CAS(A → C)，CAS 成功，但实际数据已被修改过！</pre></div></code-block><div id="cjX1WqvmmwaykkexNCw6ta" class="wolai-block wolai-text"><div><span class="inline-wrap">解决办法就是增加时间戳或者版本号</span></div></div><h2 id="41aZyrGXzicEQP27hPACqd" class="wolai-block"><span class="inline-wrap">AQS</span></h2><div id="vAEkZDhK4MkRZ5rd3c57y2" class="wolai-block wolai-text"><div><span class="inline-wrap">AbstractQueueSynchronizer 是一个抽象类，本质是一种锁，是<span class="jill"></span>Java<span class="jill"></span>实现的悲观锁，类似于<span class="jill"></span>synchronized。公平、不公平锁都可以。</span></div></div><div id="kRTu8NxaC28LT1JtcAZzTP" class="wolai-block wolai-text"><div><span class="inline-wrap">是<span class="jill"></span>ReentrantLock<span class="jill"></span>的底层实现。</span></div></div><div id="3kBxfkZfdA2PTRfJys4Naf" class="red wolai-block wolai-text"><div><span class="inline-wrap"><b>有排他锁和共享锁两种</b></span></div></div><div id="nYDkLZAfwGwdg5DYNQfdUp" class="wolai-block wolai-text"><div><span class="inline-wrap">AQS<span class="jill"></span>有<span class="jill"></span>state<span class="jill"></span>关键字代表当前是否有线程获得锁</span></div></div><div id="3GZsaBAJk6pnrsfFx9h4BP" class="wolai-block wolai-text"><div><span class="inline-wrap">线程<span class="jill"></span>0<span class="jill"></span>获得锁后，后面新来的线程<span class="jill"></span>1<span class="jill"></span>和<span class="jill"></span>2<span class="jill"></span>会进入</span><span class="inline-wrap"><b>FIFO<span class="jill"></span>队列</b></span><span class="inline-wrap">，然后等线程<span class="jill"></span>0<span class="jill"></span>运行完毕，唤醒对头线程。</span></div></div><div id="nVbfoKrxGwPct7dXERM9oD" class="wolai-block wolai-text"><div><span class="inline-wrap">state<span class="jill"></span>是使用<span class="jill"></span>CAS<span class="jill"></span>进行原子性的保证。</span></div></div><div id="iUFm1PR6r8t5jBPYiC3zHN" class="wolai-block"><figure class="wolai-center" style="width: 601.8691293744932px; flex-direction: column"><img src="media/image_5.png" style="width: 100%"/></figure></div><div id="eNKD6oBNVzjaM6q7TzWCjM" class="wolai-block"><figure class="wolai-center" style="width: 332.71026406416087px; flex-direction: column"><img src="media/image_6.png" style="width: 100%"/></figure></div><h2 id="gfg8XN8BBmQ21zkfTTK8Uo" class="wolai-block"><span class="inline-wrap">死锁</span></h2><div id="w4hAiYu3DUg8UTgvoZb8Zk" class="wolai-block wolai-text"><div><span class="inline-wrap">一个线程需要获取多把锁，就容易造成死锁</span></div></div><div id="tcEPVowUfrDwBqNS9VaweD" class="wolai-block wolai-text"><div><span class="inline-wrap">四个条件缺一不可：</span><span class="inline-wrap"><b>互斥，占有且等待，不可剥夺，循环等待</b></span></div></div><div id="oA2rA7Rg9CQTHqc7e7kfrc" class="wolai-block wolai-text"><div><span class="inline-wrap">排查死锁可以使用开源的工具<span class="jill"></span>JConsole</span></div></div><h2 id="8YBwfg4jVTsYonhoRQDCDH" class="wolai-block"><span class="inline-wrap">ConcurrentHashMap</span></h2><blockquote id="vAVR6dshX5RbmyvgyKHApv" class="wolai-block"><span class="inline-wrap">细节很多，还没补充完，面渣上面</span></blockquote><div id="nrUDit9ApBEbWmwbWkZUtn" class="wolai-block wolai-text"><div><span class="inline-wrap">问<span class="jill"></span>Hash<span class="jill"></span>的时候可能会问这个，总的来说就是多加了把</span><span class="inline-wrap"><b>锁</b></span><span class="inline-wrap">。</span></div></div><div id="bxAeFvRYyHQEK6Ut3jeuua" class="wolai-block"><figure class="wolai-center" style="width: 483.17754640778423px; flex-direction: column"><img src="media/image_7.png" style="width: 100%"/></figure></div><h3 id="5aLPD7mXpczkiYHbFHZmZ5" class="wolai-block"><span class="inline-wrap">JDK1.7</span></h3><div id="9SftRPWMz98Pg9Xu981EhS" class="wolai-block wolai-text"><div><span class="inline-wrap">将<span class="jill"></span>map<span class="jill"></span>分为不同的段，段数组初始化长度后不能扩容，段里面指向的位置数组可以扩容。</span></div></div><div id="sa7wsXG1jjkA1MXWJwsnQ4" class="wolai-block"><figure class="wolai-center" style="width: 576.6354857516496px; flex-direction: column"><img src="media/image_8.png" style="width: 100%"/></figure></div><div id="nUYUkAy4vNVwV1VcLsRJfy" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h3 id="wLb6USMgKXcqnGvWyFCsEa" class="wolai-block"><span class="inline-wrap">JDK1.8</span></h3><div id="u3ML2M9cgxgxi9fgi7SnoF" class="wolai-block wolai-text"><div><span class="inline-wrap">在<span class="jill"></span>1.8<span class="jill"></span>中实现方式和<span class="jill"></span>HashMap<span class="jill"></span>是一样的，就是多了🔒，每个桶都有一个锁。</span></div></div><div id="bqth2JwmbJe77GACSKgeBD" class="wolai-block"><figure class="wolai-center" style="width: 615.8878202760731px; flex-direction: column"><img src="media/image_9.png" style="width: 100%"/></figure></div><h2 id="7qXz2kAbUbxGy5Q7fppY8f" class="wolai-block"><span class="inline-wrap">CopyOnWriteArrayList </span></h2><div id="kuAtWw5i6K6eeiYwb8Lh6n" class="wolai-block wolai-text"><div><span class="inline-wrap">适合于读多写少的场景</span></div></div><div id="8TiencZtUbXGqQpqK4bWgE" class="wolai-block wolai-text"><div><span class="inline-wrap">当写操作的时候会创建一个新数组</span></div></div><h1 id="hCSU7SNYMZzu1nZCX6pvP5" class="wolai-block"><span class="inline-wrap">并发工具</span></h1><h2 id="v9LpiPWr5wKD6TJ7gUhggd" class="wolai-block"><span class="inline-wrap">CountDownLatch</span></h2><div id="nvpoF4uoMAvBAkLRZkicM8" class="wolai-block wolai-text"><div><span class="inline-wrap">进程间的同步</span></div></div><div id="5BRkH55dQ84GUgP91dcq2U" class="wolai-block wolai-text"><div><span class="inline-wrap">主线程必须在前置线程执行结束后才能继续执行。</span></div></div><div id="8qEpXDimT5QeCEBt7Njk9R" class="wolai-block wolai-text"><div><span class="inline-wrap">内部有一个计数器，当前置线程执行完毕一个后计数器减一，直到计数器为<span class="jill"></span>0，主线程才可以继续执行。</span></div></div><div id="chs6SmVcQpeqZuTAQ1ZCBS" class="wolai-block wolai-text"><div><span class="inline-wrap">比如王者荣耀，只有当十个角色都加载完毕后，主线程才可以进入游戏。</span></div></div><div id="4HvrrbB3dGKZ11AsxxAtLn" class="wolai-block wolai-text"><div><span class="inline-wrap">计数器的值只能被设置一次</span></div></div><h2 id="8VnMMXqm96U7Mbqapi7ZS5" class="wolai-block"><span class="inline-wrap">CyclicBarrier</span></h2><div id="ty3hcb6UAzGHmnaGnmMx7q" class="wolai-block wolai-text"><div><span class="inline-wrap">和<span class="jill"></span>CountDownLatch<span class="jill"></span>一样，但是有<span class="jill"></span>restar<span class="jill"></span>功能，可以重新设置</span></div></div><div id="2kkhong7joKegat6f6zNa8" class="wolai-block wolai-text"><div><span class="inline-wrap">这个的用途是让所有线程在屏障前等待，全部到达后再继续往下执行。</span></div></div><div id="oXYUmUJg6Rzqg5WoLAX39g" class="wolai-block wolai-text"><div><span class="inline-wrap">比如闯关：当主角的任务都执行完毕之后，才开启下一关。</span></div></div><h2 id="mwmTejL8bzGMhs1NZLPGUw" class="wolai-block"><span class="inline-wrap">对比</span></h2><div id="gXxocQ4HuzEvD2bVxNSqaY" class="wolai-block wolai-simple-table"><table><thead><tr><th style="width: 151px"><span class="inline-wrap"></span><div id="dreXWBAsNQFVA4xR2sQVXh" class="wolai-block wolai-text"><div><span class="inline-wrap">对比项</span></div></div></th><th style="width: 326px"><span class="inline-wrap"></span><div id="2SdZfxTXtU8hNqb7fUUEw5" class="wolai-block wolai-text"><div><span class="inline-wrap">CyclicBarrier</span></div></div></th><th style="width: 245px"><span class="inline-wrap"></span><div id="hY5CuEuMXpsy2ytbVxHxP4" class="wolai-block wolai-text"><div><span class="inline-wrap">CountDownLatch</span></div></div></th></tr></thead><tbody><tr><td><span class="inline-wrap"></span><div id="rUbsBiuxpy7iUSxX1E1Ksb" class="wolai-block wolai-text"><div><span class="inline-wrap">主要用途</span></div></div></td><td><span class="inline-wrap"></span><div id="cQe2dUVvXbHDccWvf3pnxe" class="wolai-block wolai-text"><div><span class="inline-wrap">让所有线程相互等待，全部到达后再继续</span></div></div></td><td><span class="inline-wrap"></span><div id="ssw7bo5vvZgW39tFpkZ3up" class="wolai-block wolai-text"><div><span class="inline-wrap">让主线程等待所有子线程执行完</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="2ES4kodu1KJcP5XSYYywJj" class="wolai-block wolai-text"><div><span class="inline-wrap">可重用性</span></div></div></td><td><span class="inline-wrap"></span><div id="ePfeW4FvoLybLDq6RmsH92" class="wolai-block wolai-text"><div><span class="inline-wrap">可重复使用，每次屏障打开后自动重置</span></div></div><div id="cD75bLnAcinBU65ABNr8jW" class="wolai-block wolai-text"><div></div></div></td><td><span class="inline-wrap"></span><div id="6ZxtVieMbFRHjCaZ3hrSMH" class="wolai-block wolai-text"><div><span class="inline-wrap">❌ 不可重复使用，计数器归零后不能恢复</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="tvjY7RxiXx5AHgEr8L7mum" class="wolai-block wolai-text"><div><span class="inline-wrap">是否可执行回调</span></div></div></td><td><span class="inline-wrap"></span><div id="uPgWqSCZtqC3ATi8k2PhcR" class="wolai-block wolai-text"><div><span class="inline-wrap">✅ 可以，所有线程到达屏障后可执行 barrierAction</span></div></div></td><td><span class="inline-wrap"></span><div id="hWoAxwewZsMM3D28RTtJLB" class="wolai-block wolai-text"><div><span class="inline-wrap">❌ 不能</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="moPS8rZtWqV7geFzUsvSAj" class="wolai-block wolai-text"><div><span class="inline-wrap">线程等待情况</span></div></div></td><td><span class="inline-wrap"></span><div id="oUhqp3DzzEgnh4JZGdSv2h" class="wolai-block wolai-text"><div><span class="inline-wrap">所有线程互相等待，一个线程未到达，其他线程都会阻塞</span></div></div></td><td><span class="inline-wrap"></span><div id="nrG6VhAWiVfrbEWbeqSV5P" class="wolai-block wolai-text"><div><span class="inline-wrap">主线程等待所有子线程完成，子线程执行完后可继续运行</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="vHfVDpuvXydktBif8MQJTY" class="wolai-block wolai-text"><div><span class="inline-wrap">适用场景</span></div></div></td><td><span class="inline-wrap"></span><div id="h9naT3LdPU7WudaCsrvWt4" class="wolai-block wolai-text"><div><span class="inline-wrap">线程相互依赖，需要同步执行</span></div></div></td><td><span class="inline-wrap"></span><div id="xoYzyxPaXmqfNiDmBHGZty" class="wolai-block wolai-text"><div><span class="inline-wrap">主线程等待子线程完成</span></div></div></td></tr><tr><td><span class="inline-wrap"></span><div id="558LuwfB4Mf5wxSshVpLot" class="wolai-block wolai-text"><div><span class="inline-wrap">示例场景</span></div></div></td><td><span class="inline-wrap"></span><div id="uzXzJDyGweATK8JNeCZW6V" class="wolai-block wolai-text"><div><span class="inline-wrap">计算任务拆分，所有线程都到达后才能继续</span></div></div></td><td><span class="inline-wrap"></span><div id="hFwTKvmeNQHomtZ69fCZCN" class="wolai-block wolai-text"><div><span class="inline-wrap">主线程等多个任务初始化完成</span></div></div></td></tr></tbody></table></div><h2 id="xaZPfAL3LJBksxchPW36zw" class="wolai-block"><span class="inline-wrap">Semaphore </span></h2><div id="6GXBE2tQpADwL8jDAn5V1F" class="wolai-block wolai-text"><div><span class="inline-wrap">操作系统的信号量，PV<span class="jill"></span>操作涉及的</span></div></div><h2 id="n5TFwvjWkHwKcbULyEBeCR" class="wolai-block"><span class="inline-wrap">Exchanger </span></h2><div id="cDDt2mQ853hMsiLje8Tego" class="wolai-block wolai-text"><div><span class="inline-wrap">两个进程交换数据用的，必须都调用<span class="jill"></span>Exchanger 才行，如果一方提前调用，那么就等待。</span></div></div><div id="kWmn1QE73PpmNxEwrp5Enp" class="wolai-block wolai-text"><div><span class="inline-wrap"></span><br/></div></div><h1 id="4nj2hdx3AgX3u3UHwwx5R9" class="wolai-block"><span class="inline-wrap">线程池</span></h1><div id="kLPf4bft4KaQgzCSFmYkT4" class="wolai-block wolai-text"><div><span class="inline-wrap">推荐阅读：</span></div></div><div id="a3PJMgBr6nT5cUtfxWeBXQ" class="wolai-bookmark wolai-block"><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">Java线程池实现原理及其在美团业务中的实践 - 美团技术团队</a><div class="info-box"><div class="text-pane"><div data-title="Java线程池实现原理及其在美团业务中的实践 - 美团技术团队"></div><div data-desc="本文开篇简述线程池概念和用途，接着结合线程池的源码，帮助读者领略线程池的设计思路，最后回归实践，通过案例讲述使用线程池遇到的问题，并给出了一种动态化线程池解决方案。"></div><div class="icon-host"><div class="icon icon-image" style="background-image: url(&quot;https://awps-assets.meituan.net/mit/blog/v20190629/asset/icon/favicon.ico?v=Whistle&amp;t=20181017-1r&quot;)"></div><div data-hostname="tech.meituan.com"></div></div></div><div class="preview-pane"></div></div></div><h2 id="t6NXe5vBExTkf9fTZCeBV4" class="wolai-block"><span class="inline-wrap">线程池的核心参数</span></h2><div id="pAZHyjti4zEEhJf9UTg4Tx" class="wolai-block wolai-text"><div><span class="inline-wrap">有七个核心参数</span></div></div><div id="skoEU7a6NCu5erzH5LfzQd" class="wolai-block"><figure class="wolai-center" style="width: 720.5607123412024px; flex-direction: column"><img src="media/image_10.png" style="width: 100%"/></figure></div><div id="xtj1znCmus1zQoXb9xXa2L" class="wolai-block wolai-text"><div><span class="inline-wrap"><u>救急线程在空闲的时候有生存时间，在忙起来的时候会一直生存。</u></span></div></div><div id="8BXZcACcLVVvDaCWvhQR5K" class="wolai-block wolai-text"><div><span class="inline-wrap">阻塞队列也满的时候，才开始使用救急线程。</span></div></div><div id="dd2ev1kq5XB4N4BZRG7bm1" class="wolai-block wolai-text"><div><span class="inline-wrap"><del>救急线程就是外包，忙的时候找外包，闲的时候就把外包开除了。</del></span></div></div><div id="s228xh2MSDo41CrLRdSfPf" class="wolai-block wolai-text"><div><span class="inline-wrap">工作流程：任务提交 → 核心线程执行 → 任务队列缓存 → 非核心线程执行 → 拒绝策略处理</span></div></div><div id="6Xxvff1nTn2ysVoEP6VT8L" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_11.png" style="width: 100%"/></figure></div><div id="uQCaggUZjSQsM2at4K9Jyn" class="wolai-block wolai-text"><div><span class="inline-wrap">线程执行完毕后并不会立即销毁，而是等待下一个任务的到来。救急线程空闲超过一定时间会销毁。</span></div></div><h2 id="qerJJkhRCVYRYZ88LHvzCk" class="wolai-block"><span class="inline-wrap">常见的阻塞队列</span></h2><div id="aPnWp3zu1tg8QaLRivc9Ti" class="wolai-block wolai-text"><div><span class="inline-wrap"><b>有界</b></span><span class="inline-wrap">：指的是队列容量大小</span></div></div><div id="wTSzLV2egJaMCFpMnQyDxo" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_12.png" style="width: 100%"/></figure></div><div id="aTMAbkF8iDLEaMrqrw4ziD" class="wolai-block wolai-text"><div><span class="inline-wrap">两把锁：链表的头尾都上了锁，入队出队互不干扰</span></div></div><div id="dTWx4Pu1MVj8RcwTzUtC6k" class="wolai-block wolai-text"><div><span class="inline-wrap">一把锁：入和出互相干扰</span></div></div><div id="eWeU6K5eLUC3TtHqz3YwMP" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_13.png" style="width: 100%"/></figure></div><h2 id="uvC5dKoG6PubjVfW5Bix9K" class="wolai-block"><span class="inline-wrap">核心线程数</span></h2><div id="vCWn6h3xGiN25XGTt4hQsw" class="wolai-block"><figure class="wolai-center" style="width: 392.52334524423475px; flex-direction: column"><img src="media/image_14.png" style="width: 100%"/></figure></div><div id="wvRVz7BxZnnroz8Z7BZsS3" class="wolai-block wolai-text"><div><span class="inline-wrap">IO<span class="jill"></span>密集型任务线程数为</span><span class="red inline-wrap"><b>2N+1</b></span><span class="inline-wrap">，N<span class="jill"></span>为<span class="jill"></span>CPU<span class="jill"></span>核数</span></div></div><div id="2SYeq59aE1MJewzi4SN9d9" class="wolai-block wolai-text"><div><span class="inline-wrap">CPU<span class="jill"></span>密集型任务线程数为</span><span class="red inline-wrap"><b>N+1</b></span></div></div><h2 id="rKgQXQY8mjcJrP1smnSLii" class="wolai-block"><span class="inline-wrap">线程提交</span></h2><ul class="wolai-block"><li id="3AEDDPDQZqvtB49wZnCUGB"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">execute<span class="jill"></span>方法没有返回值</span></li><li id="dUv1pmUjZtDavS35YtekQQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">submit 有返回值</span></li></ul><h2 id="7aojiECF5XfVngLZgsK5D6" class="wolai-block"><span class="inline-wrap">线程池关闭</span></h2><ul class="wolai-block"><li id="qViSCq5q29bc44HcmhE9je"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">shutdown ，不会立即关闭，等所有任务执行完毕后才关闭</span></li><li id="khVopS9CKysnGQp4ttPwWR"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">shutdownNow，发送<span class="jill"></span>interrupt 中断，线程响应后就立即关闭。</span></li></ul><h2 id="eJYEDFYhJyzNcnTieQb7HV" class="wolai-block"><span class="inline-wrap">线程池的种类</span></h2><div id="9AKWh1wWf8EgHeJs8BMtcX" class="wolai-block wolai-text"><div><span class="inline-wrap">不能使用</span><span class="inline-wrap"><code>Executors</code></span><span class="inline-wrap">创建线程池，都有可能会<span class="jill"></span>OOM</span></div></div><ol class="wolai-block"><li id="8r78FdyerGyJgiTLrMVNam"><div class="marker"></div><span class="inline-wrap">固定大小的线程池</span><span class="inline-wrap"><code>Executors.newFixedThreadPool(int nThreads);</code></span><span class="inline-wrap">，适合用于任务数量确定，且对线程数有明确要求的场景。例如，IO 密集型任务、数据库连接池等。</span><span class="red inline-wrap">任务队列无上限</span></li><li id="6gQXEiwbst7WpU2KfFCr1D"><div class="marker"></div><span class="inline-wrap">缓存线程池</span><span class="inline-wrap"><code>Executors.newCachedThreadPool();</code></span><span class="inline-wrap">，适用于短时间内任务量波动较大的场景。例如，短时间内有大量的文件处理任务或网络请求。</span><span class="red inline-wrap">救急线程无上限</span></li><li id="e9KT9j6JHJ4Vium1ar3hnq"><div class="marker"></div><span class="inline-wrap">定时任务线程池</span><span class="inline-wrap"><code>Executors.newScheduledThreadPool(int corePoolSize);</code></span><span class="inline-wrap">，适用于需要定时执行任务的场景。例如，定时发送邮件、定时备份数据等。</span><span class="red inline-wrap">救急线程无上限</span></li><li id="fr8ZU1w2b5dWczeU5BBZhK"><div class="marker"></div><span class="inline-wrap">单线程线程池</span><span class="inline-wrap"><code>Executors.newSingleThreadExecutor();</code></span><span class="inline-wrap">，适用于需要按顺序执行任务的场景。例如，日志记录、文件处理等。</span><span class="red inline-wrap">任务队列无上限</span></li></ol><h2 id="m3BA7RzK26weKKk4QVLopw" class="wolai-block"><span class="inline-wrap">线程池创建</span></h2><div id="hA9hmeoUCZCN6dFpCWMCBE" class="wolai-block wolai-text"><div><span class="inline-wrap">上面的都会出现<span class="jill"></span>oom<span class="jill"></span>问题，不能用这些创建线程池。</span></div></div><div id="5omk8b5CxaZ1JVxCTkCPVS" class="wolai-block wolai-text"><div><span class="inline-wrap">使用<span class="jill"></span>ThreadPoolExecutor<span class="jill"></span>创建，自定义各个参数的值。</span></div></div><h2 id="3obMqYsuNWcrvczwLPctjM" class="wolai-block"><span class="inline-wrap">拒绝策略</span></h2><ul class="wolai-block"><li id="cZX8roftKPqC5cbpiRW14m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">中止策略：无法接收新线程时，就报错</span></li><li id="g6f2Xj8pjpraLx7owbnE7F"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">调用者运行策略：交给主线程运行</span></li><li id="e49DGQAx4B7QKCUdVtdMff"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">丢弃策略：无法接收时直接丢弃，不报错</span></li><li id="g9K5H6XgPGJ4FN8cLmy5gp"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">丢弃最旧任务策略：丢弃队列里最早来的</span></li></ul><div id="wwx74NWSPRADkskBNfVjv5" class="wolai-block"><figure class="wolai-center" style="width: 369px; flex-direction: column"><img src="media/image_15.png" style="width: 100%"/></figure></div><h2 id="rNthKR3d4G7sWvTuUiUS7" class="wolai-block"><span class="inline-wrap">线程池状态</span></h2><ul class="wolai-block"><li id="3cLjHxJnyGt2V8ntkFDeYA"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>RUNNING</b></span><span class="inline-wrap">状态的线程池可以接收新任务，并处理阻塞队列中的任务；</span></li><li id="2EVLW4zYrP2H3BNURAGUzz"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>SHUTDOWN</b></span><span class="inline-wrap">状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</span></li><li id="6u2atWoWhutoMaK1LoJQhM"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>STOP</b></span><span class="inline-wrap">状态的线程池不会接收新任务，也不会处理阻塞队列中的任务，并且会尝试中断正在执行的任务；</span></li><li id="bhuLMg7EuagAxezwGaaSh4"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>TIDYING</b></span><span class="inline-wrap">状态表示所有任务已经终止；</span></li><li id="sJ18Gegd42mWrBBAWQzsSq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>TERMINATED</b></span><span class="inline-wrap">状态表示线程池完全关闭，所有线程销毁。</span></li></ul><div id="u8N1yZ9BSU6qMhLzkeguZ7" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_16.png" style="width: 100%"/></figure></div><h1 id="cE6cUAkFxcZdbfRUtDeqCP" class="wolai-block"><span class="inline-wrap">使用场景</span></h1><h2 id="pS3NxTwfkQs5YMmdVyMqTP" class="wolai-block"><span class="inline-wrap">项目里哪里用到了线程池</span></h2><div id="n3odsETDnpKwYNBn3AzxrN" class="wolai-block wolai-text"><div><span class="inline-wrap">CountDownLatch<span class="jill"></span>有点像操作系统知识，等其他进程执行完毕，主进程才会继续往下执行。</span></div></div><div id="rcSwiQ3iCiHazW7XVPPw4x" class="wolai-block"><figure class="wolai-center" style="width: 100%; flex-direction: column"><img src="media/image_17.png" style="width: 100%"/></figure></div></article><footer></footer></body></html></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/tou.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">刘同学</div><div class="author-info-description">欢迎光临我的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">23</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mouhorse"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><b>欢迎来到我的博客！</b><br>可以交换友链<br>联系方式：<a href="mailto:485182274@qq.com" title="发送邮件" class="anno_content">485182274@qq.com</a></center></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025-02-25/Hexo%E6%9C%AC%E5%9C%B0%E4%B8%8E%E4%BA%91%E7%AB%AF%E5%B8%83%E5%B1%80%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/" title="Hexo本地与云端布局不同处理办法"><img src="https://freeimghost.net/images/2025/03/03/bj2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo本地与云端布局不同处理办法"/></a><div class="content"><a class="title" href="/2025-02-25/Hexo%E6%9C%AC%E5%9C%B0%E4%B8%8E%E4%BA%91%E7%AB%AF%E5%B8%83%E5%B1%80%E4%B8%8D%E5%90%8C%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/" title="Hexo本地与云端布局不同处理办法">Hexo本地与云端布局不同处理办法</a><time datetime="2025-02-25T02:40:14.000Z" title="发表于 2025-02-25 10:40:14">2025-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025-02-24/%E8%A7%A3%E5%86%B3-Hexo-%E9%83%A8%E7%BD%B2%E5%88%B0-GitHub-Pages-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88/" title="解决 Hexo 部署到 GitHub Pages 自定义域名失效"><img src="https://freeimghost.net/images/2025/03/03/bj3.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="解决 Hexo 部署到 GitHub Pages 自定义域名失效"/></a><div class="content"><a class="title" href="/2025-02-24/%E8%A7%A3%E5%86%B3-Hexo-%E9%83%A8%E7%BD%B2%E5%88%B0-GitHub-Pages-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%A4%B1%E6%95%88/" title="解决 Hexo 部署到 GitHub Pages 自定义域名失效">解决 Hexo 部署到 GitHub Pages 自定义域名失效</a><time datetime="2025-02-24T03:00:27.000Z" title="发表于 2025-02-24 11:00:27">2025-02-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025-02-23/Butterfly-%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="Butterfly 个性化配置教程"><img src="https://freeimghost.net/images/2025/03/03/bj7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Butterfly 个性化配置教程"/></a><div class="content"><a class="title" href="/2025-02-23/Butterfly-%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/" title="Butterfly 个性化配置教程">Butterfly 个性化配置教程</a><time datetime="2025-02-23T07:35:17.000Z" title="发表于 2025-02-23 15:35:17">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025-02-23/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/" title="Hexo安装并修改主题"><img src="https://freeimghost.net/images/2025/03/03/bj1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hexo安装并修改主题"/></a><div class="content"><a class="title" href="/2025-02-23/Hexo%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98/" title="Hexo安装并修改主题">Hexo安装并修改主题</a><time datetime="2025-02-23T07:18:17.000Z" title="发表于 2025-02-23 15:18:17">2025-02-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024-10-07/MNE%E8%84%91%E7%94%B5%E9%A2%84%E5%A4%84%E7%90%86/" title="MNE脑电预处理"><img src="/img/bj8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MNE脑电预处理"/></a><div class="content"><a class="title" href="/2024-10-07/MNE%E8%84%91%E7%94%B5%E9%A2%84%E5%A4%84%E7%90%86/" title="MNE脑电预处理">MNE脑电预处理</a><time datetime="2024-10-07T08:09:14.000Z" title="发表于 2024-10-07 16:09:14">2024-10-07</time></div></div></div></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/" style="font-size: 1.1em; color: #999">毕业设计</a> <a href="/tags/%E7%A7%91%E7%A0%94/" style="font-size: 1.1em; color: #999">科研</a> <a href="/tags/%E8%84%B1%E5%9D%91%E7%AC%94%E8%AE%B0/" style="font-size: 1.37em; color: #99a4b2">脱坑笔记</a> <a href="/tags/%E9%AB%98%E6%95%B0/" style="font-size: 1.37em; color: #99a4b2">高数</a> <a href="/tags/Python/" style="font-size: 1.5em; color: #99a9bf">Python</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.37em; color: #99a4b2">数据结构</a> <a href="/tags/EEG/" style="font-size: 1.1em; color: #999">EEG</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.23em; color: #999ea6">机器学习</a></div></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站信息</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">23</div></div><div class="webinfo-item"><div class="item-name">运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2018-08-31T16:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">21.4k</div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2025-03-26T07:18:54.057Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/background.jpg);"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2025 By 刘同学</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">活出个样子给自己看</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="恭,喜,发,财" data-fontsize="15px" data-random="false" async="async"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="想找什么" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>